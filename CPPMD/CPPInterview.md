# CPP 面试题

## CPP 基础

**特殊的成员函数**

* 构造函数与析构函数;
* 拷贝构造函数与拷贝赋值函数;
* 移动构造函数与移动赋值函数;

**`new`和`malloc`的区别**

* `malloc`只分配内存不初始化; `new`分配内存且初始化, 分配完构造函数后自动调用构造函数.
* `malloc`分配内存需指定大小; `new`可以自动计算.
* `malloc`返回值是`void *`类型; `new`返回对应类型指针.
* `malloc`分配内存失败返回`NULL`; `new`分配内存失败抛出`bad_alloc`异常.

**封装**

* 数据封装: 类以外的成员无法直接修改类的属性, 只能通过属性的对应方法访问;
* 方法封装: 隐藏方法实现具体细节, 只提供接口, 内容修改不影响外部调用;

**继承**

* 子类继承基类的属性和方法;
* 继承的目的: 重用代码;
* 派生的目的: 扩展代码;
* 缺点: 基类变化子类不须变化, 增加了耦合性;

**多态**

*静态多态*

* 重载和模板;

*动态多态*

* 子类重写基类的虚函数, 通过基类指针或引用指向子类对象时, 产生的行为.
* 每个对象都有一个虚函数表指针, 指向一张虚函数表, 表中记录了虚函数的入口地址, 
子类重写基类虚函数后, 这个地址将被替换.

> 优点: 方便程序扩展;

*封装是为了代码模块化和增加安全性, 继承是为了重用和扩展现有的代码块, 
多态是为了接口复用.*

**智能指针**

* `unique_ptr`: 拥有资源的唯一所有权, 当`unique_ptr`被销毁或重置时, 资源自动释放. 
因为拥有资源唯一所有权, 无法进行赋值/复制操作, 但可以在函数中传递引用.

* `share_ptr`: 支持共享所有权, 通过**引用计数**跟踪正在使用的某个类实例的个数, 
当引用计数减少到0时, 资源自动释放.

**`static`**

`static`的使用可以分为两类, 一是用在普通变量和函数上; 二是用在类中.

* 普通变量分为全局变量和局部变量. 声明为静态全局变量是在全局区分配内存, 
并且只在当前文件可见, 在文件之外是不可见的. 其他文件定义同名变量不会发生冲突.
变量的值只在第一次执行时进行初始化. 声明为静态局部变量时与全局变量类似, 
只是作用域为局部作用域.
* 静态普通函数, 只在当前文件中可见, 其他文件中定义同名函数不会发生冲突.
* 静态成员变量, 在类中声明, 类外初始化, 所有对象共享一份数据.
* 静态成员函数, 所有对象共享同一个函数, 只能访问静态成员变量.

**`explicit`**

* 只能用来修饰类的构造函数, 阻止构造函数进行隐式转换.

**内存分配主要区域**

1. 栈区(stack)

* 自动分配和释放内存的区域, 它的大小和生命周期都是可预测的, 
函数返回时自动释放, 无需手动管理.
* 函数调用时, 局部变量和函数参数都被分配到栈上;
每当一个函数被调用时, 栈指针移动, 为新的变量分配空间.

2. 堆区(Heap)

* 动态分配和释放内存的区域, 它的大小和生命周期可以在运行时进行控制, 
必须显式释放, 避免内存泄漏.
* 通过`new`和`delete`手动分配和释放堆上的内存.

3. 全局/静态区(global/static)

* 存储全局变量和静态变量, 生命周期与程序的整个运行期间保持一致, 无需手动管理.
* 全局变量和静态变量在程序启动时就被分配, 并在程序结束时才释放.

4. 常量区(constant)

* 用于存储常量数据, 如字符串常量, 数据是只读的, 无法修改.
* 在程序启动时就被分配, 并在程序结束时才释放.

**指针和引用的区别**

* 指针保存的是指向对象的地址, 引用是对象的别名. 
* 指针需要通过解引用间接访问对象的值, 引用可以直接访问. 
* 指针初始化以后可以改变. 而引用必须初始化, 同时初始化以后不可以改变.
* 引用的本质是指针常量.

> 指针常量不可以修改指向, 但是可以修改指向的值, 常量指针刚好与之相反.

```cpp
// 指针常量
int *const p = &a;
p = &b;                 // false
*p = 10;                // true
// 常量指针
const int *p = &a;
p = &b;                 // true
*p = 10;                // false
```

**代码生成可执行文件**

* 预编译阶段: 对g++编译器指定-E参数, 生成.i文件. 这个阶段的主要工作是将所有的宏展开, 
去掉所有的条件预编译指令, 将所有的头文件包含进来, 删除注释等.
* 编译阶段: 对g++编译器指定-S参数, 生成.s汇编文件. 
这个阶段的主要工作是对代码的语法, 语义和词法等进行分析.
* 汇编阶段: 对g++编译器指定-c参数, 生成.o二进制文件.
* 链接阶段: 将各个模块之间的相互引用处理好. 把所有的静态库用到的目标文件装入程序中, 
并进行统一编址, 然后进行重定位, 即逻辑地址到物理地址的转换.

**动态库与静态库**

* 静态库: 命名方式为lib开头加上自定义的静态库名, 然后以.a结尾.
静态库实际上是一组目标文件的集合, 在链接阶段与调用的程序生成可执行文件. 

1. 优点: 代码加载速度快, 发布程序时, 不需要提供对应的库.
2. 缺点: 可执行文件体积大, 如果静态库有修改, 调用的程序需要重新编译.

* 动态库: 命名方式为lib开头加上自定义的动态库名, 然后以.so结尾.
动态库生成与位置无关的目标文件, 然后在运行时加载到内存.

1. 优点: 动态库可以共享, 节省了系统资源, 动态库进行修改后, 调用的程序无需重新编译.
2. 缺点: 加载速度比静态链接慢, 发布程序时, 需要提供动态库.

**声明与定义的区别**

* 声明是告诉编译器存在这个变量和函数, 但是需要到其它地方去寻找.
* 定义包含了声明, 但是声明不包含定义, 定义时才分配存储空间.

**`struct`和`class`区别**

* 共同点: C++中可以使用`struct`和`class`定义类, 都可以继承.
* 不同点: `struct`默认继承权限和默认访问权限是`public`, 
`class`默认继承权限和默认访问权限是`private`.

**`const`**

* 用于限定变量、指针、函数不可变, 同时明确指定了类型, 可以方便编译器做类型检查,
也增加了代码可读性.
* `const`修饰的变量必须初始化.
* `const`修饰的成员方法, 函数中的成员变量不可改变.
* `const`修饰指针, 见指针常量和常量指针.

**`const`和`define`**

* `const`可以明确指定数据类型, 而`define`没有数据类型.
* `const`常量是在编译运行阶段使用, `define`是在预处理阶段展开.
* `const`变量定义分配内存, `define`不分配内存.

**`extern`**

* 引入同一模块在其他文件中定义的全局变量和函数.
* 在C++里调用了C库定义函数, 需要使用`extern "C"`标识这个函数, 
告诉编译器使用C的方式进行编译, 防止C++的编译方式导致命名重整, 无法找到对应的C函数.

> 命名重整的原因在于C++支持函数重载, 而C不支持, 
所以C++编译时增加了函数参数的标识符.

**`this`**

* 解决同名冲突, 返回对象本身.
* `this`指针的本质是指针常量, 指针的指向不可以修改.

**右值引用**

* 右值引用指向要被销毁的对象(右值要么是字面常量,
要么是在表达式求值过程中创建的临时对象).
* move函数将左值转换为右值, 调用move函数后源对象只能赋值或销毁.

**`std::move`**

* 将左值强制转换为右值引用, 右值引用可以减少一次对象的析构和对象的构造,
以及深拷贝的次数.

```cpp
std::string str1 = "Hello CPP !";
/* ... */
std::string str2 = std::move(str1);
```

**`auto`**

* 让编译器能够根据初始值的类型自动推断变量的类型.

**强制类型转换**

* `static_cast`: 低风险的转换, 比如整数转浮点数, 字符型转整形.
* `const_cast`: 去掉`const`关键字的转换, 可以去掉带`const`的指针和引用.
* `dynamic_cast`: 使具有继承关系的基类转换为派生类, 如果不可以转换则返回`nullptr`.
* `reinterpret_cast`: 指针或引用的转换, 风险较高.

**构造函数不能是虚函数**

* 虚函数是通过虚函数表指针来调用的, 而虚函数表指针存在对象内存空间.
当一个对象调用构造函数时, 该对象还没有实例化, 即没有分配内存空间, 
所以虚函数表指针无法找到.

**析构函数尽量是虚函数**

* 析构函数不是虚函数容易引起内存泄漏.
* 为了实现多态的动态绑定, 通常将基类的指针指向子类对象.
当指针销毁时, 如果析构函数不是虚函数, 根据析构函数在继承中的调用顺序, 
则子类对象的析构函数将不会执行, 导致内存泄漏.

**析构函数不能抛出异常**

* 析构函数抛出异常, 则异常点之后的程序不能执行, 如果异常点之后有释放资源的操作,
则这部分资源无法释放, 导致内存泄漏.

**`override`**

* `override`在子类中标记某个函数, 表示想要覆盖已有的虚函数.
如果没有覆盖, 编译器会报错.

**`inline`**

* 优点: 减少函数调用的开销, 包括寄存器值的保存和实参的拷贝等.
* 缺点: 增加函数体积, 可能导致cache装不下, 从而减少了cache的命中率.
